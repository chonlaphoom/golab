# Race Condition Tests

This directory contains comprehensive race condition tests for the MCP server. These tests verify that the concurrent components of the system work correctly without data races, deadlocks, or other concurrency issues.

PS: race condition test generated by Claude Sonnet 4.5

## Test Files

### 1. `main_race_test.go` - ThreadSafeWriter Tests

Tests the thread-safe writer used by multiple worker goroutines.

**Tests:**

- `TestThreadSafeWriter_ConcurrentWrites` - Verifies 50 goroutines can write 500 messages without corruption
- `TestThreadSafeWriter_RaceDetection` - Tests concurrent read/write operations with 20 writers
- `TestThreadSafeWriter_NoDataCorruption` - Ensures JSON structure integrity with 30 concurrent writers
- `TestThreadSafeWriter_StressTest` - High-concurrency stress test with 100 goroutines

### 2. `worker_race_test.go` - Worker Pool Tests

Tests the worker pool that processes messages concurrently.

**Tests:**

- `TestWorker_ConcurrentMessageProcessing` - Validates 5 workers processing 300 messages
- `TestWorker_ErrorChannelRace` - Tests error channel handling with concurrent workers
- `TestWorker_GracefulShutdown` - Verifies workers drain 200 messages during shutdown
- `TestWorker_ChannelClosingRace` - Tests race between channel closing and worker reads
- `TestWorker_ProcessMessageConcurrency` - Tests processMessage function with 50 concurrent callers
- `TestWorker_HighLoadStress` - Stress test with 500 messages across 5 workers

### 3. `read_and_distribute_race_test.go` - Reader Tests

Tests the message reader and distribution mechanism.

**Tests:**

- `TestReadAndPushMsgs_ConcurrentConsumers` - Single reader with 5 concurrent consumers (250 messages)
- `TestReadAndPushMsgs_ContextCancellation` - Tests cancellation during active reading
- `TestReadAndPushMsgs_ErrorHandling` - Verifies error handling with invalid JSON
- `TestReadAndPushMsgs_ChannelBuffering` - Tests backpressure with small buffer (100 messages)
- `TestReadAndPushMsgs_RapidCancellation` - Tests immediate cancellation after start
- `TestReadAndPushMsgs_EOFHandling` - Validates EOF handling behavior
- `TestReadAndPushMsgs_ConcurrentStress` - Stress test with 300 messages and 10 consumers

## Running Tests

### Run Only Race Tests

```bash
make test-race-only
```

### Run Race Tests with Verbose Output

```bash
make test-race-verbose
```

### Run All Tests with Race Detector

```bash
make test-race-report
```

### Run Specific Race Test

```bash
go test -race -run TestThreadSafeWriter_ConcurrentWrites -v
```

## Test Coverage

The race tests cover:

- ✅ **Mutex synchronization** - ThreadSafeWriter mutex correctness
- ✅ **Channel operations** - Safe concurrent reads/writes to channels
- ✅ **Worker coordination** - 5 workers processing messages without races
- ✅ **Context cancellation** - Graceful shutdown with pending work
- ✅ **Error handling** - Concurrent error propagation
- ✅ **Message ordering** - Verification of message delivery guarantees
- ✅ **Resource cleanup** - No goroutine leaks or channel leaks

## Test Characteristics

- **Medium Load**: 100-500 messages per test
- **Worker Count**: 5 workers (matching production)
- **Timeouts**: 10-30 second timeouts to prevent hangs
- **Race Detector**: All tests run with `-race` flag
- **Verification**: Message counting to ensure correctness

## Key Findings

These tests verify that:

1. **ThreadSafeWriter** properly serializes concurrent writes using mutex
2. **Worker pool** processes messages without data races
3. **Channel operations** are thread-safe across multiple goroutines
4. **Context cancellation** works correctly during active processing
5. **Error propagation** doesn't cause race conditions
6. **Graceful shutdown** drains pending messages correctly

## CI/CD Integration

Add to your CI pipeline:

```yaml
# .github/workflows/test.yml
- name: Run race tests
  run: make test-race-report
```

## Performance Notes

Race tests run slower than regular tests due to the race detector overhead:

- Regular tests: ~0.5s
- Race tests: ~1.5s (3x slower)

This is expected and normal for Go's race detector.

## Troubleshooting

### Test Timeouts

If tests timeout, it may indicate a deadlock. Check:

- Channel buffer sizes
- Goroutine lifecycle management
- Context cancellation propagation

### Flaky Tests

Race condition tests can be timing-sensitive. If you see flaky failures:

- Increase timeouts
- Check for proper synchronization
- Verify channel closing order

### No Race Conditions Detected

Great! This means:

- Mutexes are used correctly
- Channel operations are safe
- No shared memory access without synchronization

## Further Reading

- [Go Race Detector](https://go.dev/doc/articles/race_detector)
- [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [Testing Concurrent Code](https://go.dev/blog/race-detector)
